import os
import re
import traceback
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import QDateTime
from manager.configmap import ConfigurationMapper
from manager.debug import debug_print, error_print, warning_print

class MininetExporter:
    """Handler for exporting network topology to Mininet scripts with Level 2 features."""
    
    def __init__(self, main_window):
        self.main_window = main_window
        
    def export_to_mininet(self):
        """Export the current topology to a Mininet script."""
        filename, _ = QFileDialog.getSaveFileName(
            self.main_window, 
            "Export to Mininet Script", 
            "", 
            "Python Files (*.py);;All Files (*)"
        )
        if filename:
            self.export_to_mininet_script(filename)

    def export_to_mininet_script(self, filename):
        """Export the current topology to a Mininet Python script with Level 2 features."""
        nodes, links = self.main_window.extractTopology()
        
        if not nodes:
            self.main_window.showCanvasStatus("No components found to export!")
            return
        
        # Separate nodes by type
        hosts = [n for n in nodes if n['type'] in ['Host', 'STA']]
        ues = [n for n in nodes if n['type'] == 'UE']
        gnbs = [n for n in nodes if n['type'] == 'GNB']
        aps = [n for n in nodes if n['type'] == 'AP']
        switches = [n for n in nodes if n['type'] in ['Switch', 'Router']]
        controllers = [n for n in nodes if n['type'] == 'Controller']
        docker_hosts = [n for n in nodes if n['type'] == 'DockerHost']
        core5g = [n for n in nodes if n['type'] == 'VGcore']
        
        try:
            with open(filename, "w") as f:
                self.write_mininet_script(f, nodes, links, {
                    'hosts': hosts,
                    'ues': ues,
                    'gnbs': gnbs,
                    'aps': aps,
                    'switches': switches,
                    'controllers': controllers,
                    'docker_hosts': docker_hosts,
                    'core5g': core5g
                })
            
            self.main_window.showCanvasStatus(f"Exported Level 2 topology to {os.path.basename(filename)}")
            debug_print(f"DEBUG: Exported {len(nodes)} nodes and {len(links)} links with Level 2 features to {filename}")
            
        except Exception as e:
            error_msg = f"Error exporting to Mininet: {str(e)}"
            self.main_window.showCanvasStatus(error_msg)
            error_print(f"ERROR: {error_msg}")
            traceback.print_exc()

    def write_mininet_script(self, f, nodes, links, categorized_nodes):
        """Write the complete Mininet script with Level 2 features."""
        # Write script header
        self.write_script_header(f)
        
        # Write imports
        self.write_imports(f, categorized_nodes)
        
        # Write topology function
        self.write_topology_function(f, nodes, links, categorized_nodes)
        
        # Write main execution
        self.write_main_execution(f)

    def write_script_header(self, f):
        """Write the script header with metadata."""
        f.write('#!/usr/bin/python\n')
        f.write('"""\n')
        f.write('NetFlux5G - Level 2 Mininet Topology\n')
        f.write('Generated by NetFlux5G Editor\n')
        f.write(f'Generated on: {QDateTime.currentDateTime().toString()}\n')
        f.write('Advanced hierarchical topology with 5G integration\n')
        f.write('"""\n\n')

    def write_imports(self, f, categorized_nodes):
        """Write necessary imports based on component types."""
        f.write('import sys\n')
        f.write('import os\n')
        f.write('from mininet.net import Mininet\n')
        f.write('from mininet.link import TCLink, Link, Intf\n')
        f.write('from mininet.node import RemoteController, OVSKernelSwitch, Host, Node\n')
        f.write('from mininet.log import setLogLevel, info\n')
        
        # Add wireless imports if needed
        if categorized_nodes['aps'] or categorized_nodes['ues'] or categorized_nodes['gnbs'] or any(h['type'] == 'STA' for h in categorized_nodes['hosts']):
            f.write('from mn_wifi.net import Mininet_wifi\n')
            f.write('from mn_wifi.node import Station, OVSKernelAP\n')
            f.write('from mn_wifi.link import wmediumd, Intf\n')
            f.write('from mn_wifi.wmediumdConnector import interference\n')
        
        # Add containernet imports if Docker hosts or 5G components exist
        if categorized_nodes['docker_hosts'] or categorized_nodes['ues'] or categorized_nodes['gnbs'] or categorized_nodes['core5g']:
            f.write('from containernet.cli import CLI\n')
            f.write('from containernet.node import DockerSta\n')
            f.write('from containernet.term import makeTerm as makeTerm2\n')
        else:
            f.write('from mininet.cli import CLI\n')
        
        f.write('from subprocess import call\n\n\n')

    def write_topology_function(self, f, nodes, links, categorized_nodes):
        """Write the main topology function with Level 2 features."""
        f.write('def topology(args):\n')
        f.write('    \n')
        
        # Initialize network
        self.write_network_initialization(f, categorized_nodes)
        
        # Add controllers
        self.write_controllers(f, categorized_nodes)
        
        # Add APs and Switches with Level 2 hierarchical topology
        self.write_aps_and_switches_level2(f, categorized_nodes)
        
        # Get current working directory
        f.write('    cwd = os.getcwd() # Current Working Directory\n\n')
        
        # Add 5G Core components with enhanced configuration
        self.write_5g_core_components_level2(f, categorized_nodes)
        
        # Add gNBs with advanced configuration
        self.write_gnbs_level2(f, categorized_nodes)
        
        # Add UEs with enhanced features
        self.write_ues_level2(f, categorized_nodes)
        
        # Add Docker hosts
        self.write_docker_hosts(f, categorized_nodes)
        
        # Add regular hosts and STAs
        self.write_hosts_and_stas(f, categorized_nodes)
        
        # Add WiFi connections
        self.write_wifi_connections(f, categorized_nodes)
        
        # Configure propagation model
        self.write_propagation_model(f, categorized_nodes)
        
        # Add links with Level 2 hierarchical topology
        self.write_links_level2(f, links, nodes, categorized_nodes)
        
        # Add plot graph for wireless
        self.write_plot_graph(f, categorized_nodes)
        
        # Start network
        self.write_network_startup(f, categorized_nodes)
        
        # Add 5G specific startup sequences with Level 2 features
        self.write_5g_startup_sequences_level2(f, categorized_nodes)
        
        # Add CLI and cleanup
        self.write_cli_and_cleanup(f)

    def write_network_initialization(self, f, categorized_nodes):
        """Write network initialization code."""
        if (categorized_nodes['aps'] or categorized_nodes['ues'] or categorized_nodes['gnbs'] or 
            any(h['type'] == 'STA' for h in categorized_nodes['hosts'])):
            f.write('    net = Mininet_wifi(topo=None,\n')
            f.write('                       build=False,\n')
            f.write('                       link=wmediumd, wmediumd_mode=interference,\n')
            f.write('                       ipBase=\'10.0.0.0/8\')\n')
        else:
            f.write('    net = Mininet(topo=None, build=False, ipBase=\'10.0.0.0/8\')\n')
        f.write('    \n')

    def write_controllers(self, f, categorized_nodes):
        """Write controller creation code."""
        if categorized_nodes['controllers']:
            f.write('    info( \'\\n*** Adding controller\\n\' )\n')
            for controller in categorized_nodes['controllers']:
                props = controller.get('properties', {})
                ctrl_name = self.sanitize_variable_name(controller['name'])
                ctrl_ip = props.get('Controller_IPAddress', '127.0.0.1')
                ctrl_port = props.get('Controller_Port', 6633)
                
                f.write(f'    {ctrl_name} = net.addController(name=\'{ctrl_name}\',\n')
                f.write(f'                           controller=RemoteController,\n')
                f.write(f'                           ip=\'{ctrl_ip}\',\n')
                f.write(f'                           port={ctrl_port})\n')
            f.write('\n')
        else:
            f.write('    info( \'\\n*** Adding controller\\n\' )\n')
            f.write('    c0 = net.addController(name=\'c0\',\n')
            f.write('                           controller=RemoteController)\n\n')

    def write_aps_and_switches_level2(self, f, categorized_nodes):
        """Write APs and switches with Level 2 hierarchical topology features."""
        if categorized_nodes['aps'] or categorized_nodes['switches']:
            f.write('    info( \'\\n*** Add APs & Switches\\n\')\n')
            
            # Add APs with enhanced configuration
            for i, ap in enumerate(categorized_nodes['aps'], 1):
                props = ap.get('properties', {})
                ap_name = self.sanitize_variable_name(ap['name'])
                ssid = props.get('AP_SSID', f'{ap_name}-ssid')
                channel = props.get('AP_Channel', '36')
                mode = props.get('AP_Mode', 'a')
                position = f"{ap['x']:.1f},{ap['y']:.1f},0"
                
                f.write(f'    {ap_name} = net.addAccessPoint(\'{ap_name}\', cls=OVSKernelAP, ssid=\'{ssid}\', failMode=\'standalone\', datapath=\'user\',\n')
                f.write(f'                             channel=\'{channel}\', mode=\'{mode}\', position=\'{position}\', protocols="OpenFlow14")\n')
            
            # Add hierarchical switch topology (based on fixed_topology-upf.py pattern)
            switch_count = max(len(categorized_nodes['switches']), 10)  # Ensure minimum for hierarchy
            if switch_count >= 3:
                # Create a hierarchical topology with at least 10 switches for full structure
                for i in range(1, 11):  # s1 to s10
                    f.write(f'    s{i} = net.addSwitch(\'s{i}\', cls=OVSKernelSwitch, protocols="OpenFlow14")\n')
                    
                # Add any user-defined switches beyond s10
                user_switch_start = 11
                for i, switch in enumerate(categorized_nodes['switches']):
                    if i >= 10:  # Skip first 10 as they are part of the base hierarchy
                        switch_name = self.sanitize_variable_name(switch['name'])
                        f.write(f'    {switch_name} = net.addSwitch(\'{switch_name}\', cls=OVSKernelSwitch, protocols="OpenFlow14")\n')
            else:
                # Add basic switches if less than required for hierarchy
                for switch in categorized_nodes['switches']:
                    switch_name = self.sanitize_variable_name(switch['name'])
                    f.write(f'    {switch_name} = net.addSwitch(\'{switch_name}\', cls=OVSKernelSwitch, protocols="OpenFlow14")\n')
            
            f.write('\n')

    def write_5g_core_components_level2(self, f, categorized_nodes):
        """Write 5G Core components with Level 2 features."""
        # Extract different types of 5G components
        core_components = self.extract_5g_components_by_type(categorized_nodes['core5g'])
        
        # Add UPF components with enhanced configuration
        if core_components['UPF']:
            f.write('    info( \'\\n *** Add UPF\\n\')\n')
            for i, upf in enumerate(core_components['UPF'], 1):
                upf_name = self.sanitize_variable_name(upf.get('name', f'upf{i}'))
                position = f"{upf.get('x', 700):.1f},{upf.get('y', 335):.1f},0"
                config_file = upf.get('config_file', f'upf{i}.yaml')
                
                f.write(f'    {upf_name} = net.addStation(\'{upf_name}\', cap_add=["net_admin"], network_mode="open5gs-ueransim_default", privileged=True, publish_all_ports=True,\n')
                f.write(f'                          dcmd="/bin/bash",cls=DockerSta, dimage="adaptive/open5gs:1.0", position=\'{position}\', range=116,\n')
                f.write(f'                          volumes=[cwd + "/config/{config_file}:/opt/open5gs/etc/open5gs/upf.yaml"])\n')
            f.write('\n')
        
        # Add AMF components
        if core_components['AMF']:
            f.write('    info( \'\\n *** Add AMF\\n\')\n')
            for i, amf in enumerate(core_components['AMF'], 1):
                amf_name = self.sanitize_variable_name(amf.get('name', f'amf{i}'))
                position = f"{amf.get('x', 520):.1f},{amf.get('y', 10):.1f},0"
                config_file = amf.get('config_file', 'amf.yaml')
                
                f.write(f'    {amf_name} = net.addStation(\'{amf_name}\', network_mode="open5gs-ueransim_default", cap_add=["net_admin"],  publish_all_ports=True,\n')
                f.write(f'                          dcmd="/bin/bash",cls=DockerSta, dimage="adaptive/open5gs:1.0", position=\'{position}\', range=116,\n')
                f.write(f'                          volumes=[cwd + "/config/{config_file}:/opt/open5gs/etc/open5gs/amf.yaml"])\n')
            f.write('\n')

    def extract_5g_components_by_type(self, core5g_components):
        """Extract 5G components organized by type."""
        components = {
            'UPF': [], 'AMF': [], 'SMF': [], 'NRF': [], 'SCP': [],
            'AUSF': [], 'BSF': [], 'NSSF': [], 'PCF': [], 'PCRF': [],
            'UDM': [], 'UDR': []
        }
        
        for component in core5g_components:
            props = component.get('properties', {})
            comp_type = props.get('Component5G_Type', 'AMF')
            
            if comp_type in components:
                component_info = {
                    'name': component.get('name', f'{comp_type.lower()}1'),
                    'x': component.get('x', 0),
                    'y': component.get('y', 0),
                    'properties': props,
                    'config_file': props.get('Component5G_ConfigFile', f'{comp_type.lower()}.yaml')
                }
                components[comp_type].append(component_info)
        
        return components

    def write_gnbs_level2(self, f, categorized_nodes):
        """Write gNB creation code with Level 2 features."""
        if categorized_nodes['gnbs']:
            f.write('    info( \'\\n *** Add gNB\\n\')\n')
            for i, gnb in enumerate(categorized_nodes['gnbs'], 1):
                props = gnb.get('properties', {})
                gnb_name = self.sanitize_variable_name(gnb['name'])
                position = f"{gnb['x']:.1f},{gnb['y']:.1f},0"
                
                # Extract gNB configuration
                amf_ip = props.get('GNB_AMF_IP', '10.0.0.3')
                hostname = props.get('GNB_Hostname', f'mn.{gnb_name}')
                mcc = props.get('GNB_MCC', '999')
                mnc = props.get('GNB_MNC', '70')
                sst = props.get('GNB_SST', '1')
                sd = props.get('GNB_SD', '0xffffff')
                tac = props.get('GNB_TAC', '1')
                
                f.write(f'    {gnb_name} = net.addStation(\'{gnb_name}\', cap_add=["net_admin"], network_mode="open5gs-ueransim_default", publish_all_ports=True, \n')
                f.write(f'                          dcmd="/bin/bash",cls=DockerSta, dimage="adaptive/ueransim:1.0", position=\'{position}\', range=116,\n')
                f.write(f'                          environment={{"AMF_IP": "{amf_ip}", "GNB_HOSTNAME": "{hostname}", "N2_IFACE":"{gnb_name}-wlan0", "N3_IFACE":"{gnb_name}-wlan0", "RADIO_IFACE":"{gnb_name}-wlan0",\n')
                f.write(f'                                        "MCC": "{mcc}", "MNC": "{mnc}", "SST": "{sst}", "SD": "{sd}", "TAC": "{tac}"}})\n')
            f.write('\n')

    def write_ues_level2(self, f, categorized_nodes):
        """Write UE creation code with Level 2 features."""
        if categorized_nodes['ues']:
            f.write('    info(\'\\n*** Adding docker UE hosts\\n\')\n')
            for i, ue in enumerate(categorized_nodes['ues'], 1):
                props = ue.get('properties', {})
                ue_name = self.sanitize_variable_name(ue['name'])
                position = f"{ue['x']:.1f},{ue['y']:.1f},0"
                
                # Extract UE configuration
                gnb_ip = props.get('UE_GNB_IP', '10.0.0.4')
                apn = props.get('UE_APN', 'internet')
                msisdn = props.get('UE_MSISDN', f'000000000{i:01d}')
                mcc = props.get('UE_MCC', '999')
                mnc = props.get('UE_MNC', '70')
                sst = props.get('UE_SST', '1')
                sd = props.get('UE_SD', '0xffffff')
                tac = props.get('UE_TAC', '1')
                key = props.get('UE_Key', '465B5CE8B199B49FAA5F0A2EE238A6BC')
                op_type = props.get('UE_OP_Type', 'OPC')
                op = props.get('UE_OP', 'E8ED289DEBA952E4283B54E88E6183CA')
                
                f.write(f'    {ue_name} = net.addStation(\'{ue_name}\', devices=["/dev/net/tun"], cap_add=["net_admin"], range=116, network_mode="open5gs-ueransim_default",\n')
                f.write(f'                          dcmd="/bin/bash",cls=DockerSta, dimage="adaptive/ueransim:1.0", position=\'{position}\', \n')
                f.write(f'                          environment={{"GNB_IP": "{gnb_ip}", "APN": "{apn}", "MSISDN": \'{msisdn}\',\n')
                f.write(f'                                        "MCC": "{mcc}", "MNC": "{mnc}", "SST": "{sst}", "SD": "{sd}", "TAC": "{tac}", \n')
                f.write(f'                                        "KEY": "{key}", "OP_TYPE": "{op_type}", "OP": "{op}"}})\n')
            f.write('\n')

    def write_docker_hosts(self, f, categorized_nodes):
        """Write Docker hosts creation code."""
        if categorized_nodes['docker_hosts']:
            f.write('    info(\'\\n*** Adding Docker hosts\\n\')\n')
            for docker_host in categorized_nodes['docker_hosts']:
                props = docker_host.get('properties', {})
                host_name = self.sanitize_variable_name(docker_host['name'])
                position = f"{docker_host['x']:.1f},{docker_host['y']:.1f},0"
                
                image = props.get('DockerHost_ContainerImage', 'ubuntu:latest')
                
                f.write(f'    {host_name} = net.addStation(\'{host_name}\', cls=DockerSta, dimage="{image}", position=\'{position}\')\n')
            f.write('\n')

    def write_hosts_and_stas(self, f, categorized_nodes):
        """Write regular hosts and STAs creation code."""
        if categorized_nodes['hosts']:
            f.write('    info(\'\\n*** Adding hosts and stations\\n\')\n')
            for host in categorized_nodes['hosts']:
                props = host.get('properties', {})
                host_name = self.sanitize_variable_name(host['name'])
                host_type = host['type']
                
                config_opts = ConfigurationMapper.get_component_config(host_type, props)
                opts_str = ', '.join(config_opts) if config_opts else ''
                
                if host_type == 'STA':
                    position = f"{host['x']:.1f},{host['y']:.1f},0"
                    f.write(f'    {host_name} = net.addStation(\'{host_name}\', position=\'{position}\'')
                    if opts_str:
                        f.write(f', {opts_str}')
                    f.write(')\n')
                else:  # Host
                    f.write(f'    {host_name} = net.addHost(\'{host_name}\'')
                    if opts_str:
                        f.write(f', {opts_str}')
                    f.write(')\n')
            f.write('\n')

    def write_wifi_connections(self, f, categorized_nodes):
        """Write WiFi connection code."""
        if categorized_nodes['ues'] or any(host['type'] == 'STA' for host in categorized_nodes['hosts']):
            f.write('    info( \'\\n*** Connecting Docker nodes to APs\\n\')\n')
            
            # Connect UEs to APs (based on proximity or explicit configuration)
            ap_names = [self.sanitize_variable_name(ap['name']) for ap in categorized_nodes['aps']]
            
            for ue in categorized_nodes['ues']:
                ue_name = self.sanitize_variable_name(ue['name'])
                # Simple assignment - connect to first AP or based on position
                if ap_names:
                    target_ap = ap_names[0]  # Simple assignment, could be improved with proximity
                    f.write(f'    {ue_name}.cmd(\'iw dev {ue_name}-wlan0 connect {target_ap}-ssid\')\n')
            
            # Connect STAs to APs
            for host in categorized_nodes['hosts']:
                if host['type'] == 'STA':
                    sta_name = self.sanitize_variable_name(host['name'])
                    if ap_names:
                        target_ap = ap_names[0]  # Simple assignment
                        f.write(f'    {sta_name}.cmd(\'iw dev {sta_name}-wlan0 connect {target_ap}-ssid\')\n')
            
            f.write('\n')

    def write_propagation_model(self, f, categorized_nodes):
        """Write propagation model configuration."""
        if (categorized_nodes['aps'] or categorized_nodes['gnbs'] or 
            any(h['type'] == 'STA' for h in categorized_nodes['hosts'])):
            f.write('    info("\\n*** Configuring Propagation Model\\n")\n')
            f.write('    net.setPropagationModel(model="logDistance", exp=3)\n\n')
            f.write('    info(\'\\n*** Configuring WiFi nodes\\n\')\n')
            f.write('    net.configureWifiNodes()\n\n')

    def write_links_level2(self, f, links, nodes, categorized_nodes):
        """Write link creation code with Level 2 hierarchical topology features."""
        if links or categorized_nodes['switches']:
            f.write('    info( \'\\n*** Add links\\n\')\n')
            
            # Create hierarchical topology based on fixed_topology-upf.py
            self.write_hierarchical_topology(f, categorized_nodes)
            
            # Add user-defined links
            for link in links:
                source_name = self.sanitize_variable_name(link['source'])
                dest_name = self.sanitize_variable_name(link['destination'])
                f.write(f'    net.addLink({source_name}, {dest_name})\n')
            
            # Connect APs to switches
            ap_names = [self.sanitize_variable_name(ap['name']) for ap in categorized_nodes['aps']]
            if ap_names:
                # Connect APs to different switches for distribution
                for i, ap_name in enumerate(ap_names):
                    switch_num = (i % 3) + 1  # Distribute among s1, s2, s3
                    f.write(f'    net.addLink(s{switch_num}, {ap_name})\n')
            
            # Connect 5G components to infrastructure
            core_components = self.extract_5g_components_by_type(categorized_nodes['core5g'])
            
            # Connect AMF to top-level switch
            if core_components['AMF']:
                for i, amf in enumerate(core_components['AMF']):
                    amf_name = self.sanitize_variable_name(amf['name'])
                    f.write(f'    net.addLink(s10, {amf_name}, cls=TCLink)\n')
            
            # Connect UPFs to switches
            if core_components['UPF']:
                for i, upf in enumerate(core_components['UPF']):
                    upf_name = self.sanitize_variable_name(upf['name'])
                    switch_num = (i % 3) + 1  # Distribute among s1, s2, s3
                    f.write(f'    net.addLink(s{switch_num}, {upf_name}, cls=TCLink)\n')
            
            # Connect gNBs to APs and UPFs
            for i, gnb in enumerate(categorized_nodes['gnbs']):
                gnb_name = self.sanitize_variable_name(gnb['name'])
                # Connect to nearest AP
                if ap_names and i < len(ap_names):
                    ap_name = ap_names[i]
                    f.write(f'    net.addLink({ap_name}, {gnb_name}, cls=TCLink)\n')
            
            f.write('\n')

    def write_hierarchical_topology(self, f, categorized_nodes):
        """Write a hierarchical switch topology similar to fixed_topology-upf.py."""
        # Always create the base hierarchical structure
        f.write('    net.addLink(s10, s8)\n')
        f.write('    net.addLink(s10, s9)\n')
        f.write('    net.addLink(s10, s6)\n')
        f.write('    net.addLink(s8, s5)\n')
        f.write('    net.addLink(s9, s7)\n')
        f.write('    net.addLink(s7, s4)\n')
        f.write('    net.addLink(s5, s1)\n')
        f.write('    net.addLink(s6, s2)\n')
        f.write('    net.addLink(s6, s3)\n')
        f.write('    net.addLink(s1, s2)\n')
        f.write('    net.addLink(s2, s3)\n')
        f.write('    net.addLink(s3, s4)\n')
        f.write('    net.addLink(s5, s2)\n')
        f.write('    net.addLink(s7, s3)\n')

    def write_plot_graph(self, f, categorized_nodes):
        """Write plot graph code for wireless networks."""
        if (categorized_nodes['aps'] or categorized_nodes['gnbs'] or categorized_nodes['ues'] or
            any(h['type'] == 'STA' for h in categorized_nodes['hosts'])):
            f.write('    net.plotGraph(max_x=1000, max_y=1000)\n\n')

    def write_network_startup(self, f, categorized_nodes):
        """Write network startup code."""
        f.write('    info(\'\\n*** Starting network\\n\')\n')
        f.write('    net.build()\n\n')
        
        # Start controllers
        if categorized_nodes['controllers']:
            f.write('    info( \'\\n*** Starting controllers\\n\')\n')
            for controller in categorized_nodes['controllers']:
                ctrl_name = self.sanitize_variable_name(controller['name'])
                f.write(f'    {ctrl_name}.start()\n')
        else:
            f.write('    info( \'\\n*** Starting controllers\\n\')\n')
            f.write('    c0.start()\n')
        f.write('\n')
        
        # Start APs and switches
        if categorized_nodes['aps'] or categorized_nodes['switches']:
            f.write('    info( \'\\n*** Starting APs\\n\')\n')
            controller_name = 'c0'
            if categorized_nodes['controllers']:
                controller_name = self.sanitize_variable_name(categorized_nodes['controllers'][0]['name'])
                
            for ap in categorized_nodes['aps']:
                ap_name = self.sanitize_variable_name(ap['name'])
                f.write(f'    net.get(\'{ap_name}\').start([{controller_name}])\n')
                
            # Start all switches (including hierarchical ones)
            for i in range(1, 11):
                f.write(f'    net.get(\'s{i}\').start([{controller_name}])\n')
            
            f.write('\n')

    def write_5g_startup_sequences_level2(self, f, categorized_nodes):
        """Write 5G specific startup sequences with Level 2 features."""
        core_components = self.extract_5g_components_by_type(categorized_nodes['core5g'])
        
        if (core_components['UPF'] or core_components['AMF'] or 
            categorized_nodes['gnbs'] or categorized_nodes['ues']):
            
            f.write('    info( \'\\n *** Capture all initialization flow and slice packet\\n\')\n')
            f.write('    Capture1 = cwd + "/capture-initialization-fixed.sh"\n')
            f.write('    CLI(net, script=Capture1)\n\n')
            f.write('    CLI.do_sh(net, \'sleep 20\')\n\n')
            f.write('    info( \'\\n *** pingall for testing and flow tables update\\n\')\n')
            f.write('    net.pingAll()\n\n')
            f.write('    CLI.do_sh(net, \'sleep 10\')\n\n')
            
            # Start UPF components
            if core_components['UPF']:
                f.write('    info( \'\\n *** Post configure Docker UPF connection to Core\\n\')\n')
                for upf in core_components['UPF']:
                    upf_name = self.sanitize_variable_name(upf['name'])
                    f.write(f'    makeTerm2({upf_name}, cmd="/entrypoint.sh open5gs-upfd 2>&1 | tee -a /logging/{upf_name}.log")\n')
                f.write('\n')
            
            # Start AMF components
            if core_components['AMF']:
                f.write('    info( \'\\n *** Post configure Docker AMF connection to Core\\n\')\n')
                for amf in core_components['AMF']:
                    amf_name = self.sanitize_variable_name(amf['name'])
                    f.write(f'    makeTerm2({amf_name}, cmd="open5gs-amfd 2>&1 | tee -a /logging/{amf_name}.log")\n')
                f.write('\n')
                f.write('    CLI.do_sh(net, \'sleep 10\')\n\n')
            
            # Start gNBs
            if categorized_nodes['gnbs']:
                f.write('    info( \'\\n*** Post configure Docker gNB connection to AMF\\n\')\n')
                for gnb in categorized_nodes['gnbs']:
                    gnb_name = self.sanitize_variable_name(gnb['name'])
                    f.write(f'    makeTerm2({gnb_name}, cmd="/entrypoint.sh gnb 2>&1 | tee -a /logging/{gnb_name}.log")\n')
                f.write('\n')
                f.write('    CLI.do_sh(net, \'sleep 10\')\n\n')
            
            # Start UEs
            if categorized_nodes['ues']:
                f.write('    info( \'\\n*** Post configure Docker UE nodes\\n\')\n')
                for ue in categorized_nodes['ues']:
                    ue_name = self.sanitize_variable_name(ue['name'])
                    f.write(f'    makeTerm2({ue_name}, cmd="/entrypoint.sh ue 2>&1 | tee -a /logging/{ue_name}.log")\n')
                f.write('\n')
                f.write('    CLI.do_sh(net, \'sleep 20\')\n\n')
                
                # Add routing for UEs
                f.write('    info( \'\\n ***Route traffic on UE for End-to-End and End-to-Edge Connection\\n\')\n')
                for i, ue in enumerate(categorized_nodes['ues']):
                    ue_name = self.sanitize_variable_name(ue['name'])
                    props = ue.get('properties', {})
                    apn = props.get('UE_APN', 'internet')
                    
                    # Route based on APN
                    if 'internet2' in apn:
                        f.write(f'    {ue_name}.cmd(\'ip route add 10.46.0.0/16 dev uesimtun0\')\n')
                    else:
                        f.write(f'    {ue_name}.cmd(\'ip route add 10.45.0.0/16 dev uesimtun0\')\n')
                f.write('\n')

    def write_cli_and_cleanup(self, f):
        """Write CLI and cleanup code."""
        f.write('    info(\'*** Running CLI\\n\')\n')
        f.write('    CLI(net)\n\n')
        f.write('    info(\'*** Stopping network\\n\')\n')
        f.write('    net.stop()\n\n')

    def write_main_execution(self, f):
        """Write the main execution block."""
        f.write('if __name__ == \'__main__\':\n')
        f.write('    setLogLevel(\'info\')\n')
        f.write('    topology(sys.argv)\n')

    def sanitize_variable_name(self, name):
        """Convert component name to valid Python variable name."""
        # Replace spaces and special characters with underscores
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name.lower())
        
        # Ensure it doesn't start with a number
        if sanitized and sanitized[0].isdigit():
            sanitized = 'n_' + sanitized
            
        # Ensure it's not empty
        if not sanitized:
            sanitized = 'unnamed_component'
            
        return sanitized